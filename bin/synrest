#!/usr/bin/ruby

####---------------------------------------------------------------------------------------------------------
SYNLIB = "#{File.dirname($0)}/../lib"
$:.unshift(SYNLIB) unless $:.include?(SYNLIB)

####---------------------------------------------------------------------------------------------------------
require 'yaml'
require 'optparse'
require 'synaptic4r'
require 'logger'
require "#{File.dirname($0)}/help"

#############################################################################################################
####---------------------------------------------------------------------------------------------------------
def credentials_configured?
  config_keys = [:key, :site, :subtenant, :uid]
  status = if File.exists?(Synaptic4r::Client.config_file)
             config = File.open(Synaptic4r::Client.config_file){|yf| YAML::load(yf)}  
             config_keys.eql?(config.keys.sort.map{|k| k.to_sym})
           else; false; end
  unless status
    puts "#{Synaptic4r::Client.config_file} not found or does not include uid, key, subtenant or site"
    exit
  end
end

####---------------------------------------------------------------------------------------------------------
def dump(cmd, input, result)
  output = if input[:dump]
             <<-DUMP
COMMAND:        #{cmd}
ARGS:           #{args.inspect}
SIGNING STRING: #{result.sign.inspect}
HTTP METHOD:    #{result.http_request}
URL:            #{result.url}
HEADERS:        #{result.headers.inspect}
              DUMP
           else; ''; end
  if input[:payload] and result.payload
    output + "PAYLOAD:\n" + result.payload
  else
    output
  end
end

####---------------------------------------------------------------------------------------------------------
def run(cmd, input)
  begin
    result = Synaptic4r::Client.new.send(cmd, input)
    {:out => (input[:dump] or input[:payload]) ? dump(cmd, input, result) : result.print, :logger => :info}
  rescue RestClient::RequestFailed, RestClient::ResourceNotFound, RestClient::Unauthorized, 
         RestClient::NotModified => err
    {:out => "#{err.message}\n" + Synaptic4r::RequestError.new(err).print, :logger => :error}
  rescue RestClient::Redirect, RestClient::ServerBrokeConnection, RestClient::RequestTimeout => err
    {:out => err.message, :logger => :error}
  rescue ArgumentError => err
    {:out => err.to_s, :logger  => :error}
  end
end

####---------------------------------------------------------------------------------------------------------
def extract_cmd(meths)
  if ARGV.first 
    if meths.include?(ARGV.first.gsub(/-/,'_').to_sym)
      ARGV.shift.gsub(/-/,'_').to_sym 
    else
      puts "Error: '#{ARGV.first}' is not a valid command"
      exit
    end
  end
end

####---------------------------------------------------------------------------------------------------------
def format_required_args(args)
  arg_name = lambda{|a| Synaptic4r::Request.rest_arg(a)[:cli_arg].first}
  args.inject("") do |f,a|
    (f + (a.kind_of?(Array) ? a.map{|v| arg_name[v]}.join('|') : arg_name[a])) + ' '  
  end.chomp(' ')
end

####---------------------------------------------------------------------------------------------------------
def set_opts(opts, input, meth_args)
  [meth_args].flatten.sort_by{|m| m.to_s}.each do |a|
    arg_info = Synaptic4r::Request.rest_arg(a)
    opts.on(arg_info[:cli_opt].first, arg_info[:cli_opt].last, arg_info[:desc]) do |v|
      input[a] = arg_info[:map].nil? ? v : arg_info[:map][v]
    end
  end
end

####---------------------------------------------------------------------------------------------------------
def extract_positional_args(meths, cmd)
  exp_args = Synaptic4r::Request.all_required_rest_args(cmd)
  exp_length = exp_args.length
  pargs = ARGV.first(exp_length)
  if pargs.include?('-h')
  elsif pargs.length < exp_length
    puts "Error: expecting args '#{format_required_args(exp_args)}'"
    exit
  else
    ARGV.slice!(0, exp_length)
  end
end

####---------------------------------------------------------------------------------------------------------
def args(opts, meths, input, cmd)
  pos_args = extract_positional_args(meths, cmd)
  all_args = Synaptic4r::Request.all_required_rest_args(cmd)
  fmt = "    %-32s %s"
  unless all_args.empty?
    opts.separator "\nargs"
    args_desc = lambda{|a| arg_info = Synaptic4r::Request.rest_arg(a)
                           opts.separator fmt % [arg_info[:cli_arg], arg_info[:desc]]}
    all_args.each do |a|
      if a.kind_of?(Array)
        opts.separator "one of"
        a.each{|e| args_desc[e]}
      else
        args_desc[a]
      end
    end
  end
end

####---------------------------------------------------------------------------------------------------------
def build_banner(opts, cmd)
  exp_args = Synaptic4r::Request.all_required_rest_args(cmd)
  opts.banner = "\nUsage: synrest #{cmd.to_s.gsub(/_/,'-')} #{format_required_args(exp_args)} [options]"
end

####---------------------------------------------------------------------------------------------------------
def process_input(opts, meths, input, cmd)
  build_banner(opts, cmd)
  args(opts, meths, input, cmd)
  opts.separator "\noptions"
  set_opts(opts, input, Synaptic4r::Request.optional_rest_args(cmd))
  opts.separator "\ndiagnostic options"
  opts.on('-u', '--dump', 'do not send request but print headers and service url'){|d| input[:dump] = true}
  opts.on('-y', '--payload', 'do not send request print payload if present'){|p| input[:payload] = true}
  opts.on('-l', '--log [file]', 'log request to file (by default file is synaptic4r.log)') do |file|
    input[:log] = true
    input[:log_file] = file
  end
  opts.on_tail('-h', '--help', "this listing\n") {
    puts 
    puts opts
    puts "Examples: synrest #{cmd.to_s.gsub(/_/,'-')} examples\n\n"
    exit
  }
end


####---------------------------------------------------------------------------------------------------------
def cmd_help(meths) 
  puts "\nUsage: synrest command args [options]" 
  puts "\nCommands"
  meths.sort_by{|m| m.to_s}.each do |m| 
    next if m.eql?(:get_started)
    meth_str = " %-30s" % m.to_s.gsub(/_/,'-')
    puts "#{meth_str} #{Synaptic4r::Request.desc(m)}"
  end
  puts "\nCommand args and options\n synrest command -h"
  puts "\nGet Started\n synrest get-started"
  puts "\nCommand examples\n synrest command examples\n\n"
end

####---------------------------------------------------------------------------------------------------------
meths = Synaptic4r::Request.rest_methods << :get_started
input = {}
cmd = extract_cmd(meths)

####---------------------------------------------------------------------------------------------------------
if cmd.eql?(:get_started)
  examples
  exit
elsif cmd
  OptionParser.new do |opts|
    process_input(opts, meths, input, cmd)
    begin
      credentials_configured?
      opts.parse!(ARGV)
    rescue OptionParser::MissingArgument, OptionParser::InvalidOption  => err
      puts err.to_s
      exit
    end
  end
else
  puts "\nsynrest provides a command line interface that maps directly onto the"
  puts "synaptic storage rest API"
  cmd_help(meths)
  exit
end

####---------------------------------------------------------------------------------------------------------
if input[:log]
  log = Logger.new(input[:log_file] || 'synaptic4r.log')
  request = run(cmd, input.merge(:dump => true))
end

####---------------------------------------------------------------------------------------------------------
result = run(cmd, input)
puts result[:out] if result[:out]

####---------------------------------------------------------------------------------------------------------
log.send(result[:logger], "\n#{request[:out]}#{result[:out]}") if input[:log]
